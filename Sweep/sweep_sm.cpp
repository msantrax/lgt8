//
// ex: set ro:
// DO NOT EDIT.
// generated by smc (http://smc.sourceforge.net/)
// from file : sweep.sm
//



//Externs



#include "sweepdefs.h"
#include "sweep.h"
#include "sweep_sm.h"

using namespace statemap;

namespace antares
{
    // Static class declarations.
    Adm_ColdStart Adm::ColdStart("Adm::ColdStart", 0);
    Adm_Idle Adm::Idle("Adm::Idle", 1);
    Adm_setParked Adm::setParked("Adm::setParked", 2);
    Adm_searchOut Adm::searchOut("Adm::searchOut", 3);
    Adm_searchIn Adm::searchIn("Adm::searchIn", 4);

    void SweepState::JobDone(SweepContext& context)
    {
        Default(context);
    }

    void SweepState::Park(SweepContext& context)
    {
        Default(context);
    }

    void SweepState::Tick(SweepContext& context)
    {
        Default(context);
    }

    void SweepState::Default(SweepContext& context)
    {
        throw (
            TransitionUndefinedException(
                context.getState().getName(),
                context.getTransition()));

    }

    void Adm_Default::JobDone(SweepContext& context)
    {
        Sweep& ctxt = context.getOwner();

        SweepState& endState = context.getState();

        context.clearState();
        try
        {
            ctxt.JobisDone();
            context.setState(endState);
        }
        catch (...)
        {
            context.setState(endState);
            throw;
        }

    }

    void Adm_ColdStart::Entry(SweepContext& context)

{
        Sweep& ctxt = context.getOwner();

        //ctxt.ShowStatus((char*)"ColdStart\n\r");
        ctxt.SetupHardware();
        ctxt.TickCallback();
    }

    void Adm_ColdStart::Tick(SweepContext& context)
    {

        context.getState().Exit(context);
        context.setState(Adm::Idle);
        context.getState().Entry(context);

    }

    void Adm_Idle::Entry(SweepContext& context)

{
        Sweep& ctxt = context.getOwner();

        ctxt.ClearQueue();
    }

    void Adm_Idle::Park(SweepContext& context)
    {
        Sweep& ctxt = context.getOwner();

        if (ctxt.isParked()==true)
        {
            context.getState().Exit(context);
            // No actions.
            context.setState(Adm::setParked);
            context.getState().Entry(context);
        }
        else if (ctxt.isInside()==true)
    
    {
            context.getState().Exit(context);
            // No actions.
            context.setState(Adm::searchOut);
            context.getState().Entry(context);
        }
        else if (ctxt.isOutside()==true)
    
    {
            context.getState().Exit(context);
            // No actions.
            context.setState(Adm::searchIn);
            context.getState().Entry(context);
        }        else
        {
             Adm_Default::Park(context);
        }

    }

    void Adm_Idle::Tick(SweepContext& context)
    {
        Sweep& ctxt = context.getOwner();

        SweepState& endState = context.getState();

        context.clearState();
        try
        {
            ctxt.ToggleFlag();
            context.setState(endState);
        }
        catch (...)
        {
            context.setState(endState);
            throw;
        }

    }

    void Adm_setParked::Entry(SweepContext& context)

{
        Sweep& ctxt = context.getOwner();

        ctxt.Park();
        ctxt.TickCallback();
    }

    void Adm_setParked::Tick(SweepContext& context)
    {

        context.getState().Exit(context);
        context.setState(Adm::Idle);
        context.getState().Entry(context);

    }

    void Adm_searchOut::Entry(SweepContext& context)

{
        Sweep& ctxt = context.getOwner();

        ctxt.Slide(1, 4);
    }

    void Adm_searchOut::JobDone(SweepContext& context)
    {
        Sweep& ctxt = context.getOwner();

        if (ctxt.isParked()==true)
        {
            context.getState().Exit(context);
            // No actions.
            context.setState(Adm::setParked);
            context.getState().Entry(context);
        }
        else if (ctxt.isInside()==true)
    
    {
            context.getState().Exit(context);
            // No actions.
            context.setState(Adm::searchOut);
            context.getState().Entry(context);
        }        else
        {
             Adm_Default::JobDone(context);
        }

    }

    void Adm_searchIn::Entry(SweepContext& context)

{
        Sweep& ctxt = context.getOwner();

        ctxt.Slide(-1, 4);
    }

    void Adm_searchIn::JobDone(SweepContext& context)
    {
        Sweep& ctxt = context.getOwner();

        if (ctxt.isParked()==true)
        {
            context.getState().Exit(context);
            // No actions.
            context.setState(Adm::setParked);
            context.getState().Entry(context);
        }
        else if (ctxt.isOutside()==true)
    
    {
            context.getState().Exit(context);
            // No actions.
            context.setState(Adm::searchIn);
            context.getState().Entry(context);
        }        else
        {
             Adm_Default::JobDone(context);
        }

    }
}

//
// Local variables:
//  buffer-read-only: t
// End:
//
